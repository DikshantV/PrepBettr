/**
 * Text Preprocessing Utilities
 * 
 * Functions to clean and prepare text for Text-to-Speech (TTS) services
 * by removing markdown formatting, symbols, and other unwanted characters.
 */

/**
 * Clean Markdown formatting and symbols from text before sending to TTS
 * 
 * @param text - Raw text that may contain Markdown formatting
 * @returns Cleaned text suitable for speech synthesis
 */
export function cleanTextForTTS(text: string): string {
  if (!text || typeof text !== 'string') {
    return '';
  }

  let cleanedText = text;

  // Remove Markdown headers (# ## ### #### ##### ######)
  cleanedText = cleanedText.replace(/^#{1,6}\s*/gm, '');
  
  // Remove Markdown bold and italic formatting (** __ * _)
  cleanedText = cleanedText.replace(/\*{1,2}([^*]+)\*{1,2}/g, '$1');
  cleanedText = cleanedText.replace(/_{1,2}([^_]+)_{1,2}/g, '$1');
  
  // Remove Markdown horizontal rules (--- or ***)
  cleanedText = cleanedText.replace(/^[-*]{3,}\s*$/gm, '');
  
  // Remove Markdown code blocks (```code```)
  cleanedText = cleanedText.replace(/```[\s\S]*?```/g, '');
  
  // Remove inline code (`code`)
  cleanedText = cleanedText.replace(/`([^`]+)`/g, '$1');
  
  // Remove Markdown links ([text](url) -> text)
  cleanedText = cleanedText.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
  
  // Remove HTML tags if any
  cleanedText = cleanedText.replace(/<[^>]*>/g, '');
  
  // Remove excessive whitespace and normalize line breaks
  cleanedText = cleanedText.replace(/\n{3,}/g, '\n\n'); // Max 2 consecutive newlines
  cleanedText = cleanedText.replace(/[ \t]+/g, ' '); // Multiple spaces/tabs to single space
  
  // Remove leading/trailing whitespace from each line
  cleanedText = cleanedText.split('\n').map(line => line.trim()).join('\n');
  
  // Remove empty lines at start and end
  cleanedText = cleanedText.trim();
  
  // Replace multiple consecutive spaces with single space
  cleanedText = cleanedText.replace(/\s{2,}/g, ' ');
  
  // Ensure periods for better speech pacing (add period if sentence doesn't end with punctuation)
  cleanedText = cleanedText.replace(/([a-zA-Z0-9])\n/g, '$1. ');
  
  return cleanedText;
}

/**
 * Extract clean question text from formatted AI responses
 * Specifically handles interview question formats with headers and metadata
 * 
 * @param text - Formatted text that may contain question metadata
 * @returns Clean question text suitable for speech
 */
export function extractQuestionForTTS(text: string): string {
  if (!text || typeof text !== 'string') {
    return '';
  }

  let cleanedText = text;
  
  // Remove structured headers and metadata commonly generated by AI
  // Remove "### Role:", "### Category:", etc.
  cleanedText = cleanedText.replace(/###?\s*\w+:\s*[^\n]*/g, '');
  
  // Remove "**Question N:**" type headers
  cleanedText = cleanedText.replace(/\*{1,2}\s*Question\s+\d+[^*]*\*{1,2}/g, '');
  
  // Remove "**Question Text:**" labels
  cleanedText = cleanedText.replace(/\*{1,2}\s*Question\s+Text:\s*\*{1,2}/g, '');
  
  // Remove other structured labels like "Key:", "Expected:", etc.
  cleanedText = cleanedText.replace(/\*{1,2}\s*\w+:\s*\*{1,2}/g, '');
  
  // Remove numbered list prefixes (1., 2., etc.)
  cleanedText = cleanedText.replace(/^\d+\.\s*/gm, '');
  
  // Apply general markdown cleaning
  cleanedText = cleanTextForTTS(cleanedText);
  
  // Split into sentences and find the actual question
  const sentences = cleanedText.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 0);
  
  // Look for the longest sentence that seems like a question or main content
  const questionSentence = sentences.find(sentence => 
    sentence.includes('?') || 
    sentence.length > 20 || 
    /\b(describe|explain|tell|how|what|why|when|where)\b/i.test(sentence)
  );
  
  // Return the question sentence or the first substantial sentence
  const result = questionSentence || sentences.find(s => s.length > 15) || cleanedText;
  
  // Ensure it ends with proper punctuation for speech
  if (result && !/[.!?]$/.test(result.trim())) {
    return result.trim() + '.';
  }
  
  return result.trim();
}

/**
 * Prepare conversation text for natural speech output
 * Handles common conversational patterns and improves speech flow
 * 
 * @param text - Conversation text
 * @returns Text optimized for natural speech synthesis
 */
export function prepareConversationForTTS(text: string): string {
  if (!text || typeof text !== 'string') {
    return '';
  }

  let cleanedText = cleanTextForTTS(text);
  
  // Add natural pauses after greetings
  cleanedText = cleanedText.replace(/^(Hello|Hi|Hey|Good morning|Good afternoon)[,!]?\s*/i, '$1! ');
  
  // Add pause after "Great!" or "Excellent!" responses
  cleanedText = cleanedText.replace(/^(Great|Excellent|Perfect|Wonderful)[!]?\s*/i, '$1! ');
  
  // Ensure questions end with question marks for proper intonation
  cleanedText = cleanedText.replace(/\?\.$/g, '?');
  
  // Add slight pause after transition words
  cleanedText = cleanedText.replace(/\b(Now|Next|So|Well|However|Therefore)\s+/gi, '$1, ');
  
  // Ensure proper punctuation for speech rhythm
  if (cleanedText && !/[.!?]$/.test(cleanedText.trim())) {
    cleanedText = cleanedText.trim() + '.';
  }
  
  return cleanedText;
}

/**
 * Validate that text is suitable for TTS (not too long, has content, etc.)
 * 
 * @param text - Text to validate
 * @returns Object with validation result and cleaned text
 */
export function validateAndCleanForTTS(text: string): { 
  isValid: boolean; 
  cleanedText: string; 
  issues: string[]; 
} {
  const issues: string[] = [];
  
  if (!text || typeof text !== 'string') {
    return { isValid: false, cleanedText: '', issues: ['Text is empty or invalid'] };
  }
  
  const cleanedText = prepareConversationForTTS(text);
  
  // Check length constraints (typical TTS services have limits)
  if (cleanedText.length > 5000) {
    issues.push('Text is too long for optimal TTS processing (>5000 characters)');
  }
  
  if (cleanedText.length < 3) {
    issues.push('Text is too short for meaningful speech output');
  }
  
  // Check for remaining problematic characters
  const problematicChars = cleanedText.match(/[#*_`\[\]{}]/g);
  if (problematicChars && problematicChars.length > 0) {
    issues.push(`Contains unhandled formatting characters: ${[...new Set(problematicChars)].join(', ')}`);
  }
  
  // Check for repeated patterns that might cause speech issues
  const repeatedPatterns = cleanedText.match(/(.{3,})\1{2,}/g);
  if (repeatedPatterns) {
    issues.push('Contains repeated text patterns that may affect speech quality');
  }
  
  return {
    isValid: issues.length === 0,
    cleanedText,
    issues
  };
}
