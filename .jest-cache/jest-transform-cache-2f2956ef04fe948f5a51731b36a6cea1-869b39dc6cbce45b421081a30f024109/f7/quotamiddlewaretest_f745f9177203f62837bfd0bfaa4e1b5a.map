{"file":"/Users/dikshantvashistha/PrepBettr/tests/quota-middleware.test.ts","mappings":";AAAA,mEAAmE;AACnE,iFAAiF;AACjF,oEAAoE;AAEpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAucE","names":[],"sources":["/Users/dikshantvashistha/PrepBettr/tests/quota-middleware.test.ts"],"sourcesContent":["// tests/quota-middleware.test.ts - DISABLED (quota system removed)\n// This test file has been disabled because the quota middleware has been removed\n// to eliminate payment and usage restrictions from the application.\n\n/*\nimport { withQuota } from '@/lib/middleware/quota-middleware';\nimport { firebaseVerification } from '@/lib/services/firebase-verification';\nimport { subscriptionService } from '@/lib/services/subscription-service';\nimport { NextRequest, NextResponse } from 'next/server';\n\n// Mock the services\njest.mock('@/lib/services/firebase-verification', () => ({\n  firebaseVerification: {\n    verifyIdToken: jest.fn(),\n  },\n}));\n\njest.mock('@/lib/services/subscription-service', () => ({\n  subscriptionService: {\n    getUserSubscription: jest.fn(),\n    getUserUsage: jest.fn(),\n    incrementUsage: jest.fn(),\n    initializeUsageCounters: jest.fn(),\n    canPerformAction: jest.fn(),\n    getUserSubscriptionStatus: jest.fn(),\n  },\n}));\n\n// Mock dependencies\nconst mockVerifyIdToken = firebaseVerification.verifyIdToken as jest.MockedFunction<typeof firebaseVerification.verifyIdToken>;\nconst mockGetUserSubscription = subscriptionService.getUserSubscription as jest.MockedFunction<typeof subscriptionService.getUserSubscription>;\nconst mockGetUserUsage = subscriptionService.getUserUsage as jest.MockedFunction<typeof subscriptionService.getUserUsage>;\nconst mockIncrementUsage = subscriptionService.incrementUsage as jest.MockedFunction<typeof subscriptionService.incrementUsage>;\nconst mockInitializeUsageCounters = subscriptionService.initializeUsageCounters as jest.MockedFunction<typeof subscriptionService.initializeUsageCounters>;\nconst mockCanPerformAction = subscriptionService.canPerformAction as jest.MockedFunction<typeof subscriptionService.canPerformAction>;\nconst mockGetUserSubscriptionStatus = subscriptionService.getUserSubscriptionStatus as jest.MockedFunction<typeof subscriptionService.getUserSubscriptionStatus>;\n\ndescribe('Quota Middleware', () => {\n  let mockRequest: Partial<NextRequest>;\n  let mockHandler: jest.Mock;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    \n    mockRequest = {\n      cookies: {\n        get: jest.fn(),\n      } as any,\n    };\n    \n    mockHandler = jest.fn().mockResolvedValue({ status: 200 });\n  });\n\n  describe('Development Mode', () => {\n    beforeEach(() => {\n      process.env.NODE_ENV = 'development';\n    });\n\n    afterEach(() => {\n      process.env.NODE_ENV = 'test';\n    });\n\n    it('should skip quota enforcement in development mode', async () => {\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      await wrappedHandler(mockRequest as NextRequest);\n\n      expect(mockHandler).toHaveBeenCalled();\n      expect(mockGetUserSubscription).not.toHaveBeenCalled();\n    });\n\n    it('should extract userId in development mode when session exists', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'test-session-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'test-user-id' } as any,\n      });\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      await wrappedHandler(mockRequest as NextRequest);\n\n      expect(mockHandler).toHaveBeenCalledWith(mockRequest, { userId: 'test-user-id' });\n    });\n  });\n\n  describe('Production Mode', () => {\n    beforeEach(() => {\n      process.env.NODE_ENV = 'production';\n    });\n\n    afterEach(() => {\n      process.env.NODE_ENV = 'test';\n    });\n\n    it('should return 401 when no session cookie is provided', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue(undefined);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(401);\n      expect(mockHandler).not.toHaveBeenCalled();\n    });\n\n    it('should return 401 when session verification fails', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'invalid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: false,\n        error: 'Invalid token',\n      });\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(401);\n      expect(mockHandler).not.toHaveBeenCalled();\n    });\n\n    it('should allow premium users unlimited access', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'premium-user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: true,\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'premium',\n        planStatus: 'active',\n        hasPremium: true,\n        premiumSource: 'subscription',\n        emailVerified: true,\n        usage: null\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(mockHandler).toHaveBeenCalledWith(mockRequest, { userId: 'premium-user-id' });\n      expect(response.status).toBe(200);\n    });\n\n    it('should enforce quota limits for free users', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'free-user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: false,\n        reason: \"You've reached your interviews limit for the free plan\",\n        upgradeRequired: true\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          interviews: {\n            count: 5,\n            limit: 5,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(402);\n      expect(mockHandler).not.toHaveBeenCalled();\n    });\n\n    it('should allow free users within quota limits', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'free-user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: true,\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          interviews: {\n            count: 3,\n            limit: 5,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(mockHandler).toHaveBeenCalledWith(mockRequest, { userId: 'free-user-id' });\n      expect(response.status).toBe(200);\n    });\n\n    it('should increment usage counter on successful request', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'free-user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: true,\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          interviews: {\n            count: 3,\n            limit: 5,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n      mockIncrementUsage.mockResolvedValue(true);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      await wrappedHandler(mockRequest as NextRequest);\n\n      // Give time for async increment\n      await new Promise(resolve => setTimeout(resolve, 100));\n\n      expect(mockIncrementUsage).toHaveBeenCalledWith('free-user-id', 'interviews');\n    });\n\n    it('should initialize usage counters when no usage record exists', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'new-user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: true,\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: null\n      } as any);\n      mockInitializeUsageCounters.mockResolvedValue();\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(200);\n    });\n\n    it('should handle errors gracefully', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockRejectedValue(new Error('Service unavailable'));\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(500);\n      expect(mockHandler).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Feature-specific behavior', () => {\n    beforeEach(() => {\n      process.env.NODE_ENV = 'production';\n    });\n\n    afterEach(() => {\n      process.env.NODE_ENV = 'test';\n    });\n\n    it('should handle resume tailoring feature', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: true,\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          resumeTailor: {\n            count: 2,\n            limit: 3,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'resumeTailor',\n        limitFree: 3,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(200);\n    });\n\n    it('should handle auto apply feature', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({\n        canPerform: false,\n        reason: \"You've reached your auto-apply job application limit for the free plan\",\n        upgradeRequired: true\n      });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          autoApply: {\n            count: 10,\n            limit: 10,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'autoApply',\n        limitFree: 10,\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      const response = await wrappedHandler(mockRequest as NextRequest);\n\n      expect(response.status).toBe(402);\n      expect(JSON.parse(response.body)).toMatchObject({\n        success: false,\n        error: \"You've reached your auto-apply job application limit for the free plan\",\n        feature: 'autoApply',\n        upgradeUrl: '/pricing',\n      });\n    });\n  });\n\n  describe('Custom usage document ID', () => {\n    beforeEach(() => {\n      process.env.NODE_ENV = 'production';\n    });\n\n    afterEach(() => {\n      process.env.NODE_ENV = 'test';\n    });\n\n    it('should use custom usage document ID when provided', async () => {\n      (mockRequest.cookies!.get as jest.Mock).mockReturnValue({ value: 'valid-token' });\n      mockVerifyIdToken.mockResolvedValue({\n        success: true,\n        decodedToken: { uid: 'user-id' } as any,\n      });\n      mockCanPerformAction.mockResolvedValue({ canPerform: true });\n      mockGetUserSubscriptionStatus.mockResolvedValue({\n        plan: 'free',\n        planStatus: 'active',\n        hasPremium: false,\n        premiumSource: null,\n        emailVerified: true,\n        usage: {\n          interviews: {\n            count: 1,\n            limit: 5,\n            updatedAt: new Date(),\n          }\n        }\n      } as any);\n\n      const middleware = withQuota({\n        featureKey: 'interviews',\n        limitFree: 5,\n        usageDocId: 'custom-doc-id',\n      });\n\n      const wrappedHandler = middleware(mockHandler);\n      await wrappedHandler(mockRequest as NextRequest);\n\n      expect(mockCanPerformAction).toHaveBeenCalledWith('custom-doc-id', 'interviews', true);\n    });\n  });\n});\n*/\n"],"version":3}