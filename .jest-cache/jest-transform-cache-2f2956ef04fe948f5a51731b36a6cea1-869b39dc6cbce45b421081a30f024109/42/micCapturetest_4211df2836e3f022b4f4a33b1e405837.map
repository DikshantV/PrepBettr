{"file":"/Users/dikshantvashistha/PrepBettr/lib/audio/__tests__/micCapture.test.ts","mappings":"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","names":[],"sources":["/Users/dikshantvashistha/PrepBettr/lib/audio/__tests__/micCapture.test.ts"],"sourcesContent":["import { MicCapture } from '../micCapture';\n\n// Mock AudioContext and related APIs for testing\nclass MockAudioContext {\n  sampleRate = 48000;\n  state = 'running';\n  \n  audioWorklet = {\n    addModule: jest.fn().mockResolvedValue(undefined)\n  };\n  \n  createMediaStreamSource = jest.fn().mockReturnValue({\n    connect: jest.fn(),\n    disconnect: jest.fn()\n  });\n  \n  resume = jest.fn().mockResolvedValue(undefined);\n  close = jest.fn().mockResolvedValue(undefined);\n}\n\nclass MockAudioWorkletNode {\n  port = {\n    postMessage: jest.fn(),\n    onmessage: null\n  };\n  \n  connect = jest.fn();\n  disconnect = jest.fn();\n  \n  constructor(context, processorName) {}\n}\n\nclass MockMediaStream {\n  getTracks = jest.fn().mockReturnValue([\n    { stop: jest.fn() }\n  ]);\n}\n\n// Mock navigator.mediaDevices\nconst mockGetUserMedia = jest.fn();\nObject.defineProperty(navigator, 'mediaDevices', {\n  value: {\n    getUserMedia: mockGetUserMedia\n  },\n  configurable: true\n});\n\n// Mock global constructors\n(global as any).AudioContext = MockAudioContext;\n(global as any).AudioWorkletNode = MockAudioWorkletNode;\n(global as any).URL = class {\n  href: string;\n  constructor(url: string, base?: string) {\n    this.href = url;\n  }\n};\n\ndescribe('MicCapture', () => {\n  let micCapture: MicCapture;\n  \n  beforeEach(() => {\n    micCapture = new MicCapture();\n    mockGetUserMedia.mockResolvedValue(new MockMediaStream());\n  });\n  \n  afterEach(async () => {\n    if (micCapture.capturing) {\n      await micCapture.dispose();\n    }\n    jest.clearAllMocks();\n  });\n  \n  describe('Initialization', () => {\n    test('should initialize successfully', async () => {\n      await expect(micCapture.initialize()).resolves.not.toThrow();\n      expect(mockGetUserMedia).toHaveBeenCalledWith({\n        audio: {\n          sampleRate: 48000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true,\n          autoGainControl: true\n        }\n      });\n    });\n    \n    test('should throw error if initialization fails', async () => {\n      mockGetUserMedia.mockRejectedValue(new Error('Permission denied'));\n      await expect(micCapture.initialize()).rejects.toThrow('Failed to initialize microphone capture');\n    });\n  });\n  \n  describe('Capture Control', () => {\n    beforeEach(async () => {\n      await micCapture.initialize();\n    });\n    \n    test('should start capture successfully', async () => {\n      await expect(micCapture.startCapture()).resolves.not.toThrow();\n      expect(micCapture.capturing).toBe(true);\n    });\n    \n    test('should stop capture successfully', async () => {\n      await micCapture.startCapture();\n      micCapture.stopCapture();\n      expect(micCapture.capturing).toBe(false);\n    });\n    \n    test('should throw error when starting capture without initialization', async () => {\n      const uninitializedCapture = new MicCapture();\n      await expect(uninitializedCapture.startCapture()).rejects.toThrow('MicCapture not initialized');\n    });\n  });\n  \n  describe('Properties', () => {\n    test('should return correct sample rate', () => {\n      expect(micCapture.sampleRate).toBe(16000);\n    });\n    \n    test('should return correct frame size (100ms at 16kHz)', () => {\n      expect(micCapture.frameSize).toBe(1600);\n    });\n  });\n  \n  describe('Offline Sine Wave Test', () => {\n    test('should process sine wave without byte-order flip', async () => {\n      // Create a mock shared buffer for testing\n      const frameSize = 1600; // 100ms at 16kHz\n      const bufferFrames = 10;\n      const headerSize = 2;\n      const bufferSize = headerSize + (frameSize * bufferFrames);\n      const sharedBuffer = new SharedArrayBuffer(bufferSize * Int16Array.BYTES_PER_ELEMENT);\n      const sharedBufferView = new Int16Array(sharedBuffer);\n      \n      // Initialize buffer indices\n      Atomics.store(sharedBufferView, 0, 0); // writeIndex\n      Atomics.store(sharedBufferView, 1, 0); // readIndex\n      \n      // Generate a sine wave at 440Hz (A4) for testing\n      const sampleRate = 16000;\n      const frequency = 440;\n      const amplitude = 16000; // Use a significant amplitude for testing\n      const testSamples = frameSize;\n      \n      // Generate sine wave samples\n      const sineWave = new Int16Array(testSamples);\n      for (let i = 0; i < testSamples; i++) {\n        const t = i / sampleRate;\n        const sample = Math.round(amplitude * Math.sin(2 * Math.PI * frequency * t));\n        sineWave[i] = Math.max(-32768, Math.min(32767, sample));\n      }\n      \n      // Simulate writing sine wave to shared buffer\n      for (let i = 0; i < testSamples; i++) {\n        const bufferIndex = headerSize + i;\n        sharedBufferView[bufferIndex] = sineWave[i];\n      }\n      \n      // Update write index to indicate data is available\n      Atomics.store(sharedBufferView, 0, testSamples);\n      \n      // Mock the shared buffer in micCapture\n      (micCapture as any).sharedBufferView = sharedBufferView;\n      (micCapture as any).isCapturing = true;\n      \n      // Read one frame using the private readFrame method\n      const frame = (micCapture as any).readFrame();\n      \n      expect(frame).not.toBeNull();\n      expect(frame.length).toBe(frameSize);\n      \n      // Verify that the data matches our sine wave (no byte-order flip)\n      for (let i = 0; i < Math.min(testSamples, frame.length); i++) {\n        expect(frame[i]).toBe(sineWave[i]);\n      }\n      \n      // Test byte conversion to Uint8Array\n      micCapture.stopCapture();\n      (micCapture as any).isCapturing = true;\n      \n      // Get one frame from the async iterator\n      const iterator = micCapture.read();\n      const result = await iterator.next();\n      \n      expect(result.done).toBe(false);\n      expect(result.value).toBeInstanceOf(Uint8Array);\n      expect(result.value!.length).toBe(frameSize * 2); // 2 bytes per sample\n      \n      // Verify byte order (little-endian)\n      const uint8Frame = result.value!;\n      for (let i = 0; i < Math.min(10, frameSize); i++) { // Test first 10 samples\n        const originalSample = sineWave[i];\n        const lowByte = uint8Frame[i * 2];\n        const highByte = uint8Frame[i * 2 + 1];\n        const reconstructedSample = lowByte | (highByte << 8);\n        \n        // Handle signed 16-bit conversion\n        const signedSample = reconstructedSample > 32767 ? reconstructedSample - 65536 : reconstructedSample;\n        expect(signedSample).toBe(originalSample);\n      }\n    });\n    \n    test('should handle empty buffer gracefully', async () => {\n      // Mock empty shared buffer\n      const frameSize = 1600;\n      const bufferFrames = 10;\n      const headerSize = 2;\n      const bufferSize = headerSize + (frameSize * bufferFrames);\n      const sharedBuffer = new SharedArrayBuffer(bufferSize * Int16Array.BYTES_PER_ELEMENT);\n      const sharedBufferView = new Int16Array(sharedBuffer);\n      \n      // Initialize buffer indices (both at 0, indicating empty buffer)\n      Atomics.store(sharedBufferView, 0, 0); // writeIndex\n      Atomics.store(sharedBufferView, 1, 0); // readIndex\n      \n      (micCapture as any).sharedBufferView = sharedBufferView;\n      \n      // Read frame from empty buffer\n      const frame = (micCapture as any).readFrame();\n      expect(frame).toBeNull();\n    });\n  });\n  \n  describe('Resource Cleanup', () => {\n    test('should dispose resources properly', async () => {\n      await micCapture.initialize();\n      await micCapture.startCapture();\n      \n      await expect(micCapture.dispose()).resolves.not.toThrow();\n      expect(micCapture.capturing).toBe(false);\n    });\n  });\n});\n"],"version":3}