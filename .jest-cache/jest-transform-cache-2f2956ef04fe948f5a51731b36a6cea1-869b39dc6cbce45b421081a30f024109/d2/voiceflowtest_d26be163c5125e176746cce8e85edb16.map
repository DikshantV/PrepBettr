{"file":"/Users/dikshantvashistha/PrepBettr/tests/integration/voice-flow.test.ts","mappings":"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","names":[],"sources":["/Users/dikshantvashistha/PrepBettr/tests/integration/voice-flow.test.ts"],"sourcesContent":["import { describe, it, expect, beforeAll, afterAll } from '@jest/globals';\nimport fetch from 'node-fetch';\nimport FormData from 'form-data';\nimport fs from 'fs';\nimport path from 'path';\n\n// Test configuration\nconst API_BASE_URL = process.env.TEST_API_URL || 'http://localhost:3000';\nconst TEST_TIMEOUT = 30000; // 30 seconds\n\ndescribe('Voice STT → OpenAI Data Flow Integration', () => {\n  let testAudioPath: string;\n  \n  beforeAll(() => {\n    // Path to test WAV file\n    testAudioPath = path.join(__dirname, '../fixtures/test-audio.wav');\n    \n    // Create a test WAV file if it doesn't exist\n    if (!fs.existsSync(testAudioPath)) {\n      // Create directory if it doesn't exist\n      const fixturesDir = path.dirname(testAudioPath);\n      if (!fs.existsSync(fixturesDir)) {\n        fs.mkdirSync(fixturesDir, { recursive: true });\n      }\n      \n      // Create a simple WAV file with silence (44 bytes header + some data)\n      const wavHeader = Buffer.alloc(44);\n      // RIFF header\n      wavHeader.write('RIFF', 0);\n      wavHeader.writeUInt32LE(36 + 1600, 4); // File size - 8\n      wavHeader.write('WAVE', 8);\n      \n      // fmt subchunk\n      wavHeader.write('fmt ', 12);\n      wavHeader.writeUInt32LE(16, 16); // Subchunk size\n      wavHeader.writeUInt16LE(1, 20); // Audio format (PCM)\n      wavHeader.writeUInt16LE(1, 22); // Number of channels\n      wavHeader.writeUInt32LE(16000, 24); // Sample rate\n      wavHeader.writeUInt32LE(32000, 28); // Byte rate\n      wavHeader.writeUInt16LE(2, 32); // Block align\n      wavHeader.writeUInt16LE(16, 34); // Bits per sample\n      \n      // data subchunk\n      wavHeader.write('data', 36);\n      wavHeader.writeUInt32LE(1600, 40); // Data size\n      \n      // Write header and some silence data\n      const silenceData = Buffer.alloc(1600); // 100ms of silence at 16kHz\n      fs.writeFileSync(testAudioPath, Buffer.concat([wavHeader, silenceData]));\n    }\n  });\n  \n  describe('/api/voice/stream endpoint', () => {\n    it('should always return success:true with text field', async () => {\n      const formData = new FormData();\n      formData.append('audio', fs.createReadStream(testAudioPath), {\n        filename: 'test-audio.wav',\n        contentType: 'audio/wav'\n      });\n      \n      const response = await fetch(`${API_BASE_URL}/api/voice/stream`, {\n        method: 'POST',\n        body: formData as any,\n        headers: formData.getHeaders()\n      });\n      \n      expect(response.status).toBe(200);\n      \n      const result = await response.json() as any;\n      \n      // Verify the response structure\n      expect(result).toHaveProperty('success');\n      expect(result.success).toBe(true);\n      expect(result).toHaveProperty('text');\n      expect(typeof result.text).toBe('string');\n      \n      // Even with empty/silent audio, should return success with empty text\n      expect(result).toHaveProperty('confidence');\n      expect(typeof result.confidence).toBe('number');\n    }, TEST_TIMEOUT);\n    \n    it('should handle missing audio file gracefully', async () => {\n      const formData = new FormData();\n      // Don't append any audio file\n      \n      const response = await fetch(`${API_BASE_URL}/api/voice/stream`, {\n        method: 'POST',\n        body: formData as any,\n        headers: formData.getHeaders()\n      });\n      \n      expect(response.status).toBe(200);\n      \n      const result = await response.json() as any;\n      \n      // Should still return success with empty text\n      expect(result.success).toBe(true);\n      expect(result.text).toBe('');\n      expect(result).toHaveProperty('error');\n    }, TEST_TIMEOUT);\n    \n    it('should handle invalid audio format gracefully', async () => {\n      const formData = new FormData();\n      // Send a text file instead of audio\n      const invalidData = Buffer.from('This is not audio data');\n      formData.append('audio', invalidData, {\n        filename: 'invalid.txt',\n        contentType: 'text/plain'\n      });\n      \n      const response = await fetch(`${API_BASE_URL}/api/voice/stream`, {\n        method: 'POST',\n        body: formData as any,\n        headers: formData.getHeaders()\n      });\n      \n      expect(response.status).toBe(200);\n      \n      const result = await response.json() as any;\n      \n      // Should still return success with empty text\n      expect(result.success).toBe(true);\n      expect(result.text).toBe('');\n      expect(result).toHaveProperty('error');\n      expect(result.error).toContain('Unsupported audio format');\n    }, TEST_TIMEOUT);\n  });\n  \n  describe('/api/voice/conversation endpoint', () => {\n    it('should process text and return AI response', async () => {\n      // First, start the conversation\n      const startResponse = await fetch(`${API_BASE_URL}/api/voice/conversation`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'start',\n          interviewContext: {\n            type: 'general',\n            maxQuestions: 5\n          }\n        })\n      });\n      \n      expect(startResponse.status).toBe(200);\n      \n      const startResult = await startResponse.json() as any;\n      expect(startResult.success).toBe(true);\n      expect(startResult).toHaveProperty('message');\n      expect(startResult).toHaveProperty('questionNumber');\n      \n      // Then process a user response\n      const processResponse = await fetch(`${API_BASE_URL}/api/voice/conversation`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          action: 'process',\n          userTranscript: 'I have 5 years of experience in software development'\n        })\n      });\n      \n      expect(processResponse.status).toBe(200);\n      \n      const processResult = await processResponse.json() as any;\n      expect(processResult.success).toBe(true);\n      expect(processResult).toHaveProperty('message');\n      expect(processResult).toHaveProperty('questionNumber');\n      expect(processResult).toHaveProperty('isComplete');\n    }, TEST_TIMEOUT);\n    \n    it('should handle retry with exponential backoff', async () => {\n      // This test simulates multiple rapid requests to test retry logic\n      const promises = [];\n      \n      for (let i = 0; i < 3; i++) {\n        promises.push(\n          fetch(`${API_BASE_URL}/api/voice/conversation`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              action: 'process',\n              userTranscript: `Test message ${i}`\n            })\n          })\n        );\n      }\n      \n      const responses = await Promise.all(promises);\n      \n      // All requests should eventually succeed\n      for (const response of responses) {\n        expect(response.status).toBe(200);\n        const result = await response.json() as any;\n        expect(result).toHaveProperty('success');\n      }\n    }, TEST_TIMEOUT * 2);\n  });\n  \n  describe('End-to-End Voice Flow', () => {\n    it('should complete full STT → OpenAI flow', async () => {\n      // Step 1: Upload audio to STT\n      const formData = new FormData();\n      formData.append('audio', fs.createReadStream(testAudioPath), {\n        filename: 'test-audio.wav',\n        contentType: 'audio/wav'\n      });\n      \n      const sttResponse = await fetch(`${API_BASE_URL}/api/voice/stream`, {\n        method: 'POST',\n        body: formData as any,\n        headers: formData.getHeaders()\n      });\n      \n      expect(sttResponse.status).toBe(200);\n      \n      const sttResult = await sttResponse.json() as any;\n      expect(sttResult.success).toBe(true);\n      expect(sttResult).toHaveProperty('text');\n      \n      // Step 2: If we got text, send it to conversation API\n      if (sttResult.text && sttResult.text.trim()) {\n        const conversationResponse = await fetch(`${API_BASE_URL}/api/voice/conversation`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            action: 'process',\n            userTranscript: sttResult.text\n          })\n        });\n        \n        expect(conversationResponse.status).toBe(200);\n        \n        const conversationResult = await conversationResponse.json() as any;\n        expect(conversationResult.success).toBe(true);\n        expect(conversationResult).toHaveProperty('message');\n        expect(typeof conversationResult.message).toBe('string');\n      }\n    }, TEST_TIMEOUT);\n  });\n  \n  afterAll(() => {\n    // Cleanup can be added here if needed\n  });\n});\n"],"version":3}